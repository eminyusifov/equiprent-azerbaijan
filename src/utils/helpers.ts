// Форматирование цен\nexport const formatPrice = (price: number, currency: string = 'USD'): string => {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: currency,\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 2\n  }).format(price);\n};\n\n// Форматирование дат\nexport const formatDate = (date: string | Date, locale: string = 'en-US'): string => {\n  const d = typeof date === 'string' ? new Date(date) : date;\n  return new Intl.DateTimeFormat(locale, {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  }).format(d);\n};\n\n// Форматирование относительного времени\nexport const formatRelativeTime = (date: string | Date): string => {\n  const now = new Date();\n  const targetDate = typeof date === 'string' ? new Date(date) : date;\n  const diffInSeconds = Math.floor((now.getTime() - targetDate.getTime()) / 1000);\n\n  const intervals = [\n    { label: 'year', seconds: 31536000 },\n    { label: 'month', seconds: 2592000 },\n    { label: 'week', seconds: 604800 },\n    { label: 'day', seconds: 86400 },\n    { label: 'hour', seconds: 3600 },\n    { label: 'minute', seconds: 60 },\n    { label: 'second', seconds: 1 }\n  ];\n\n  for (const interval of intervals) {\n    const count = Math.floor(Math.abs(diffInSeconds) / interval.seconds);\n    if (count >= 1) {\n      const suffix = count === 1 ? '' : 's';\n      const prefix = diffInSeconds < 0 ? 'in ' : '';\n      const postfix = diffInSeconds < 0 ? '' : ' ago';\n      return `${prefix}${count} ${interval.label}${suffix}${postfix}`;\n    }\n  }\n\n  return 'just now';\n};\n\n// Вычисление продолжительности в днях\nexport const calculateDaysBetween = (startDate: string, endDate: string): number => {\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n  const diffTime = Math.abs(end.getTime() - start.getTime());\n  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n};\n\n// Генерация диапазона дат\nexport const generateDateRange = (startDate: string, endDate: string): string[] => {\n  const dates = [];\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n  \n  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\n    dates.push(new Date(d).toISOString().split('T')[0]);\n  }\n  \n  return dates;\n};\n\n// Проверка является ли дата выходным\nexport const isWeekend = (date: string | Date): boolean => {\n  const d = typeof date === 'string' ? new Date(date) : date;\n  const day = d.getDay();\n  return day === 0 || day === 6; // Sunday = 0, Saturday = 6\n};\n\n// Получение следующего рабочего дня\nexport const getNextWorkingDay = (date: string | Date): Date => {\n  const d = typeof date === 'string' ? new Date(date) : new Date(date);\n  \n  do {\n    d.setDate(d.getDate() + 1);\n  } while (isWeekend(d));\n  \n  return d;\n};\n\n// Форматирование номера телефона для Азербайджана\nexport const formatPhoneNumber = (phone: string): string => {\n  // Удаляем все символы кроме цифр\n  const cleaned = phone.replace(/\\D/g, '');\n  \n  // Проверяем формат Азербайджана\n  if (cleaned.startsWith('994')) {\n    const withoutCountry = cleaned.substring(3);\n    if (withoutCountry.length === 9) {\n      return `+994 ${withoutCountry.substring(0, 2)} ${withoutCountry.substring(2, 5)} ${withoutCountry.substring(5)}`;\n    }\n  }\n  \n  return phone; // Возвращаем исходный если не подходит под формат\n};\n\n// Валидация email\nexport const isValidEmail = (email: string): boolean => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\n// Валидация телефона Азербайджана\nexport const isValidAzerbaijanPhone = (phone: string): boolean => {\n  const phoneRegex = /^\\+994\\s\\d{2}\\s\\d{3}\\s\\d{4}$/;\n  return phoneRegex.test(phone);\n};\n\n// Генерация случайного ID\nexport const generateId = (): string => {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\n};\n\n// Truncate text\nexport const truncateText = (text: string, maxLength: number): string => {\n  if (text.length <= maxLength) return text;\n  return text.substring(0, maxLength) + '...';\n};\n\n// Capitalize first letter\nexport const capitalize = (text: string): string => {\n  return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();\n};\n\n// Slug generation\nexport const generateSlug = (text: string): string => {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9 -]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-') // Replace spaces with hyphens\n    .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen\n    .trim();\n};\n\n// Deep clone object\nexport const deepClone = <T>(obj: T): T => {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj.getTime()) as unknown as T;\n  if (obj instanceof Array) return obj.map(item => deepClone(item)) as unknown as T;\n  if (typeof obj === 'object') {\n    const clonedObj = {} as T;\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clonedObj[key] = deepClone(obj[key]);\n      }\n    }\n    return clonedObj;\n  }\n  return obj;\n};\n\n// Check if object is empty\nexport const isEmpty = (obj: any): boolean => {\n  if (obj == null) return true;\n  if (Array.isArray(obj) || typeof obj === 'string') return obj.length === 0;\n  if (typeof obj === 'object') return Object.keys(obj).length === 0;\n  return false;\n};\n\n// Debounce function\nexport const debounce = <T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void => {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n};\n\n// Throttle function\nexport const throttle = <T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void => {\n  let inThrottle: boolean;\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n};\n\n// Get file size in human readable format\nexport const formatFileSize = (bytes: number): string => {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\n// Color utilities\nexport const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\nexport const rgbToHex = (r: number, g: number, b: number): string => {\n  return \"#\" + [r, g, b].map(x => {\n    const hex = x.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n  }).join(\"\");\n};\n\n// Local storage helpers\nexport const storage = {\n  get: <T>(key: string, defaultValue: T): T => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch {\n      return defaultValue;\n    }\n  },\n  \n  set: <T>(key: string, value: T): void => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n    }\n  },\n  \n  remove: (key: string): void => {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.error('Failed to remove from localStorage:', error);\n    }\n  },\n  \n  clear: (): void => {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.error('Failed to clear localStorage:', error);\n    }\n  }\n};\n"