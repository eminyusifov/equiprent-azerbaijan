import { useState, useEffect } from 'react';\n\n// Хук для работы с localStorage\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, (value: T | ((val: T) => T)) => void] {\n  // Получаем значение из localStorage или используем начальное значение\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  // Функция для установки значения\n  const setValue = (value: T | ((val: T) => T)) => {\n    try {\n      // Позволяем value быть функцией, как в useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\n// Хук для отслеживания пересечения элемента с viewport\nexport function useIntersectionObserver(\n  elementRef: React.RefObject<Element>,\n  {\n    threshold = 0,\n    root = null,\n    rootMargin = '0%',\n    freezeOnceVisible = false,\n  }: {\n    threshold?: number;\n    root?: Element | null;\n    rootMargin?: string;\n    freezeOnceVisible?: boolean;\n  } = {}\n): boolean {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  useEffect(() => {\n    const element = elementRef?.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const isElementIntersecting = entry.isIntersecting;\n        if (!freezeOnceVisible || !isIntersecting) {\n          setIsIntersecting(isElementIntersecting);\n        }\n      },\n      { threshold, root, rootMargin }\n    );\n\n    observer.observe(element);\n\n    return () => {\n      observer.unobserve(element);\n    };\n  }, [elementRef, threshold, root, rootMargin, freezeOnceVisible, isIntersecting]);\n\n  return isIntersecting;\n}\n\n// Хук для отслеживания размера окна\nexport function useWindowSize() {\n  const [windowSize, setWindowSize] = useState({\n    width: undefined as number | undefined,\n    height: undefined as number | undefined,\n  });\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n\n    window.addEventListener('resize', handleResize);\n    handleResize();\n\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n}\n\n// Хук для определения мобильного устройства\nexport function useIsMobile(breakpoint: number = 768): boolean {\n  const { width } = useWindowSize();\n  return width ? width < breakpoint : false;\n}\n\n// Хук для копирования в буфер обмена\nexport function useClipboard(timeout: number = 2000) {\n  const [isCopied, setIsCopied] = useState(false);\n\n  const copyToClipboard = async (text: string) => {\n    if (navigator.clipboard && window.isSecureContext) {\n      try {\n        await navigator.clipboard.writeText(text);\n        setIsCopied(true);\n        setTimeout(() => setIsCopied(false), timeout);\n        return true;\n      } catch (error) {\n        console.error('Failed to copy to clipboard:', error);\n        return false;\n      }\n    } else {\n      // Fallback для старых браузеров\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      textArea.style.position = 'fixed';\n      textArea.style.left = '-999999px';\n      textArea.style.top = '-999999px';\n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      \n      try {\n        document.execCommand('copy');\n        setIsCopied(true);\n        setTimeout(() => setIsCopied(false), timeout);\n        return true;\n      } catch (error) {\n        console.error('Failed to copy to clipboard:', error);\n        return false;\n      } finally {\n        document.body.removeChild(textArea);\n      }\n    }\n  };\n\n  return { isCopied, copyToClipboard };\n}\n\n// Хук для работы с темой\nexport function useTheme() {\n  const [theme, setTheme] = useLocalStorage<'light' | 'dark'>('theme', 'light');\n\n  useEffect(() => {\n    const root = window.document.documentElement;\n    if (theme === 'dark') {\n      root.classList.add('dark');\n    } else {\n      root.classList.remove('dark');\n    }\n  }, [theme]);\n\n  const toggleTheme = () => {\n    setTheme(theme === 'light' ? 'dark' : 'light');\n  };\n\n  return { theme, setTheme, toggleTheme };\n}\n\n// Хук для обнаружения клика вне элемента\nexport function useClickOutside(\n  ref: React.RefObject<HTMLElement>,\n  handler: () => void\n) {\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (ref.current && !ref.current.contains(event.target as Node)) {\n        handler();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [ref, handler]);\n}\n\n// Хук для отслеживания предыдущего значения\nexport function usePrevious<T>(value: T): T | undefined {\n  const ref = React.useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n// Хук для toggle состояния\nexport function useToggle(initialValue: boolean = false): [boolean, () => void] {\n  const [value, setValue] = useState(initialValue);\n  const toggle = () => setValue(v => !v);\n  return [value, toggle];\n}\n\n// Хук для async операций\nexport function useAsync<T, E = string>(\n  asyncFunction: () => Promise<T>,\n  immediate = true\n) {\n  const [status, setStatus] = useState<'idle' | 'pending' | 'success' | 'error'>('idle');\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<E | null>(null);\n\n  const execute = React.useCallback(async () => {\n    setStatus('pending');\n    setData(null);\n    setError(null);\n\n    try {\n      const response = await asyncFunction();\n      setData(response);\n      setStatus('success');\n    } catch (error) {\n      setError(error as E);\n      setStatus('error');\n    }\n  }, [asyncFunction]);\n\n  useEffect(() => {\n    if (immediate) {\n      execute();\n    }\n  }, [execute, immediate]);\n\n  return {\n    execute,\n    status,\n    data,\n    error,\n    isLoading: status === 'pending',\n    isError: status === 'error',\n    isSuccess: status === 'success',\n    isIdle: status === 'idle'\n  };\n}\n\n// Хук для работы с массивом\nexport function useArray<T>(initialArray: T[] = []) {\n  const [array, setArray] = useState(initialArray);\n\n  const push = (element: T) => {\n    setArray(arr => [...arr, element]);\n  };\n\n  const filter = (callback: (item: T, index: number) => boolean) => {\n    setArray(arr => arr.filter(callback));\n  };\n\n  const update = (index: number, newElement: T) => {\n    setArray(arr => [\n      ...arr.slice(0, index),\n      newElement,\n      ...arr.slice(index + 1)\n    ]);\n  };\n\n  const remove = (index: number) => {\n    setArray(arr => [...arr.slice(0, index), ...arr.slice(index + 1)]);\n  };\n\n  const clear = () => {\n    setArray([]);\n  };\n\n  return {\n    array,\n    set: setArray,\n    push,\n    filter,\n    update,\n    remove,\n    clear\n  };\n}\n\n// Хук для отслеживания онлайн статуса\nexport function useOnlineStatus(): boolean {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  return isOnline;\n}\n\n// Импорт React для usePrevious\nimport React from 'react';\n"